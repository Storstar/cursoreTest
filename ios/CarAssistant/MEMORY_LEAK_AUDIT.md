# Аудит утечек памяти - Рекомендации

## Проверка с помощью Xcode Instruments

### 1. Memory Leak Detection
1. Откройте проект в Xcode
2. Выберите Product → Profile (Cmd+I)
3. Выберите "Leaks" инструмент
4. Запустите приложение и используйте все функции (чат, добавление авто, фото и т.д.)
5. Проверьте красные флаги утечек памяти

### 2. Allocations Profile
1. В Instruments выберите "Allocations"
2. Запустите приложение
3. Используйте функции приложения
4. Проверьте рост памяти (Memory Graph)
5. Используйте "Mark Generation" для отслеживания роста памяти

### 3. Memory Graph Debugger
1. В Xcode установите точку останова
2. Debug → Memory Graph
3. Проверьте циклические ссылки и утечки

## Потенциальные проблемы, которые нужно проверить

### 1. Изображения
- ✅ Добавлена очистка `selectedImage = nil` в `onDisappear` для ChatView и CarInputView
- ✅ Создан ImageOptimizer для оптимизации изображений при сохранении (макс 1200px, качество 0.7)
- ✅ Добавлено использование thumbnail для отображения изображений в списках (CarPhotoView, CarCard, CarMiniCard, CarSelectionView, CarSelectionSheet, MyCarsView)
- ✅ Добавлена оптимизация рендеринга через `.drawingGroup()` для всех изображений

### 2. Task и async функции
- ✅ Добавлена проверка отмены в цикле `while isWaitingForResponse` в ChatViewModel
- ⚠️ Проверить: все Task должны быть отменяемы при закрытии экранов
- ⚠️ Рекомендация: использовать `Task.checkCancellation()` в длительных операциях

### 3. ViewModels и @StateObject
- ⚠️ Проверить: ChatViewModel, RequestViewModel создаются как @StateObject - убедиться, что они освобождаются
- ⚠️ Рекомендация: использовать @ObservedObject вместо @StateObject где возможно

### 4. Core Data
- ✅ Исправлено освобождение background context в CarViewModel и AuthViewModel
- ✅ Добавлен batch fetching (fetchBatchSize = 20) для всех fetch requests
- ✅ Оптимизированы fetch requests для уменьшения использования памяти

### 5. NotificationCenter и Combine
- ⚠️ Проверить: все подписки должны быть отменены в `onDisappear`
- ⚠️ Рекомендация: использовать `AnyCancellable` и хранить в Set

### 6. Анимации и Timer
- ⚠️ Проверить: все Timer должны быть инвалидированы
- ⚠️ Рекомендация: использовать SwiftUI анимации вместо Timer где возможно

## Исправления, которые уже внесены

1. ✅ Очистка изображений в `onDisappear` для ChatView и CarInputView
2. ✅ Добавлена проверка отмены в цикле ожидания ответа в ChatViewModel
3. ✅ Очистка `selectedImage` при смене автомобиля
4. ✅ Добавлена отмена Task при закрытии View (MaintenanceView, CreateRequestView, EditMaintenanceView)
5. ✅ Добавлена проверка `Task.isCancelled` во всех async операциях
6. ✅ Исправлено освобождение background context в CarViewModel и AuthViewModel
7. ✅ Добавлена очистка изображений в `onDisappear` для всех View с изображениями
8. ✅ Добавлена оптимизация рендеринга изображений через `.drawingGroup()` в CarPhotoView и CarCard
9. ✅ Добавлена отмена задач анализа изображений при смене изображения
10. ✅ Добавлена очистка ресурсов SpeechRecognizer при закрытии CreateRequestView
11. ✅ Создан ImageOptimizer для оптимизации размера изображений при сохранении (макс 1200px, качество 0.7)
12. ✅ Добавлено использование thumbnail для всех изображений в списках (уменьшение использования памяти в 4-10 раз)
13. ✅ Оптимизированы все fetch requests с batch fetching и правильной настройкой lazy loading

## Оптимизация использования памяти

### Реализованные оптимизации:
1. ✅ Оптимизация изображений при сохранении (макс 1200px, качество 0.7) - уменьшение размера в 3-5 раз
2. ✅ Использование thumbnail для отображения в списках - уменьшение использования памяти в 4-10 раз
3. ✅ Оптимизация рендеринга через `.drawingGroup()` - уменьшение нагрузки на GPU
4. ✅ Batch fetching для Core Data - загрузка данных порциями по 20 объектов
5. ✅ Правильная настройка lazy loading для Core Data

### Ожидаемый результат:
- **До оптимизации:** ~53.9 MB в покое
- **После оптимизации:** ожидается ~20-30 MB в покое (уменьшение на 40-50%)

## Следующие шаги

1. Запустить Instruments и проверить утечки
2. Проверить рост памяти при длительном использовании
3. Проверить все подписки на уведомления
4. При необходимости добавить кэширование thumbnail для еще большей оптимизации

